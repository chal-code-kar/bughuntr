package com.tcs.utx.digiframe.controller;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

import com.tcs.utx.digiframe.model.TempAccess;
import com.tcs.utx.digiframe.model.UpdateStatus;
import com.tcs.utx.digiframe.model.Vulnerability;
import com.tcs.utx.digiframe.service.BrandingDetailsService;
import com.tcs.utx.digiframe.service.PermissionHelperService;
import com.tcs.utx.digiframe.service.ProgramService;
import com.tcs.utx.digiframe.service.VulnerabilityService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@RestController
@RequestMapping("/BugHuntr/api/v1/")
public class VulnerabilityAPI {

	private static final Logger LOG = LoggerFactory.getLogger(VulnerabilityAPI.class);

	private static final String GLB_ERROR_MSG = "An error has occured please try again or contact Administrator";

	private String TEXT_VULNERABILITY = "Vulnerability";

	private String TEXT_VIEW_VULNERABILITY = "View Vulnerabilities";

	private String TEXT_ERROR = "error";

	private String ACCESS_DENIED = "Access Denied";

	private String TEXT_APPROVE = "Approve";

	private String TEXT_PROGRAMID = "programid";

	private String TEXT_NO_VULN = "No Vulnerability found";

	private String TEXT_STATUS = "status";

	public static final String ERROR = "Something Went Wrong.";

	public String VULN_VALIDATION = "VulnerabilityController | Validation Failed in addvulnerability";

	public String TEXT_DELETE = "Deleted Successfully";
	
	
	@Autowired
	private VulnerabilityService service;

	@Autowired
	private PermissionHelperService permissionService;

	@Autowired
	private ProgramService programService;

	@Autowired
	private BrandingDetailsService brandingService;

	@RequestMapping(value = "vulnerabilities", method = RequestMethod.POST, produces = "text/plain; charset=utf-8")
	public ResponseEntity<String> addvulnerability(@RequestBody Vulnerability vulnerability) {
		try {
			LOG.info("VulnerabilityController | addvulnerability Begin");
			int emp_id = BrandingDetailsController.getUser();

			boolean isGuest = brandingService.isUserGuest();
			if (isGuest) {
				return new ResponseEntity<>(ACCESS_DENIED, HttpStatus.FORBIDDEN);
			}

			vulnerability.setResearcherid(emp_id);
			String retData = this.service.validateVuln(vulnerability);
			if (retData != null) {
				LOG.info(VULN_VALIDATION);
				return new ResponseEntity<>(retData, HttpStatus.BAD_REQUEST);
			}
			if (!this.permissionService.isOperationPermissible(TEXT_VULNERABILITY, "New Vulnerability", "Add", emp_id,
					0, vulnerability.getProgramid())) {
				LOG.info("VulnerabilityController | User don't has access for adding New Vulnerability");
				return new ResponseEntity<>("ACCESS_DENIED", HttpStatus.FORBIDDEN);
			}
			LOG.info("VulnerabilityController | addvulnerability Exit");

		} catch (DataAccessException e) {
			LOG.error("VulnerabilityController | DataAccessexception in addvulnerability - ", e);
			return new ResponseEntity<>(GLB_ERROR_MSG, HttpStatus.INTERNAL_SERVER_ERROR);
		} catch (Exception e) {
			LOG.error("VulnerabilityController | Exception in addvulnerability", e);
			return new ResponseEntity<>(GLB_ERROR_MSG, HttpStatus.INTERNAL_SERVER_ERROR);
		}
		return new ResponseEntity<>(String.valueOf(this.service.reportvuln(vulnerability)), HttpStatus.OK);

	}

	@RequestMapping(value = "vulnerabilities", method = RequestMethod.GET,produces = "application/json; charset=utf-8")
	public ResponseEntity<List<Map<String, Object>>> getAllvulnerabilities() {
		List<Map<String, Object>> a = new ArrayList<>();
		Map<String, Object> error = new HashMap<>();
		
		try {
			LOG.info("VulnerabilityController | getAllvulnerability Begin");
			int emp_id = BrandingDetailsController.getUser();

			boolean isGuest = brandingService.isUserGuest();
			if (isGuest) {
				error.put(TEXT_ERROR, ACCESS_DENIED);
				a.add(error);
				LOG.info("VulnerabilityController | Access Denied in getAllvulnerability");
				return new ResponseEntity<>(a, HttpStatus.FORBIDDEN);
			}
			if (!this.permissionService.isOperationPermissible(TEXT_VULNERABILITY, TEXT_VIEW_VULNERABILITY, "View",
					emp_id, 0, 0)) {
				error.put(TEXT_ERROR, ACCESS_DENIED);
				a.add(error);
				LOG.info("VulnerabilityController | Access Denied in getAllvulnerability");
				return new ResponseEntity<>(a, HttpStatus.FORBIDDEN);
			}

			a = this.service.getAllvulnerabilities();

			LOG.info("VulnerabilityController | getAllvulnerability Exit");
		} catch (DataAccessException e) {
			LOG.error("VulnerabilityController | DataAccessexception in getAllvulnerabilities - ", e);
			return new ResponseEntity<>(null, HttpStatus.INTERNAL_SERVER_ERROR);
		} catch (Exception e) {
			LOG.error("VulnerabilityController | Exception in getAllvulnerabilities", e);
			return new ResponseEntity<>(null, HttpStatus.INTERNAL_SERVER_ERROR);
		}

		return new ResponseEntity<>(a, HttpStatus.OK);

	}

	@RequestMapping(value = "vulnerabilities/{srno}", method = RequestMethod.GET,produces = "application/json; charset=utf-8")
	public ResponseEntity<Map<String, Object>> getVulnerabilityById(@PathVariable int srno) {
		Map<String, Object> map = new HashMap<>();
		List<Map<String, Object>> data = new ArrayList<Map<String, Object>>();
		LOG.info("VulnerabilityController | getVulnerabilityById Begin");
		try {
			int emp_id = BrandingDetailsController.getUser();
			boolean isEditable = false;
			boolean canApprove = false;

			boolean isGuest = brandingService.isUserGuest();
			if (isGuest) {
				map.put("text", ACCESS_DENIED);
				return new ResponseEntity<>(map, HttpStatus.FORBIDDEN);
			}

			data = this.service.getVulnerabilityById(srno);
			if (data == null) {
				data = new ArrayList<>();
				map.put(TEXT_ERROR, ACCESS_DENIED);
				data.add(map);
				LOG.info("VulnerabilityController | Access Denied in getVulnerabilityById");
				return new ResponseEntity<>(map, HttpStatus.BAD_REQUEST);
			}
			if ((int) data.get(0).get("researcherid") == emp_id) {
				isEditable = true;
			}
			if (this.permissionService.isOperationPermissible(TEXT_VULNERABILITY, TEXT_APPROVE, TEXT_APPROVE, emp_id, 0,
					(int) data.get(0).get(TEXT_PROGRAMID))) {
				canApprove = true;
			}
			data.get(0).put("isEditable", isEditable);
			data.get(0).put("canApprove", canApprove);

			if (this.programService.ifprogramAdmin(emp_id, (int) data.get(0).get(TEXT_PROGRAMID))) {
				LOG.info("VulnerabilityController | getVulnerabilityById Exit");
				return new ResponseEntity<>(data.get(0), HttpStatus.OK);
			} else if (!this.permissionService.isOperationPermissible(TEXT_VULNERABILITY, TEXT_VIEW_VULNERABILITY,
					"View", emp_id, srno, 0)) {
				data = new ArrayList<>();
				map.put(TEXT_ERROR, ACCESS_DENIED);
				data.add(map);
				LOG.info("VulnerabilityController | Access Denied in getVulnerabilityById");
				return new ResponseEntity<>(map, HttpStatus.FORBIDDEN);
			} else {
				;
			}
			LOG.info("VulnerabilityController | getVulnerabilityById Exit");

		} catch (DataAccessException e) {
			LOG.error("VulnerabilityController | DataAccessexception in getVulnerabilityById - ", e);
			return new ResponseEntity<>(null, HttpStatus.INTERNAL_SERVER_ERROR);
		} catch (Exception e) {
			LOG.error("VulnerabilityController | Exception in getVulnerabilityById", e);
			return new ResponseEntity<>(null, HttpStatus.INTERNAL_SERVER_ERROR);
		}
		return new ResponseEntity<>(data.get(0), HttpStatus.OK);

	}

	@RequestMapping(value = "updatedvulnerabilities/{id}", method = RequestMethod.POST, produces = "text/plain; charset=utf-8")
	public ResponseEntity<String> updateVulnerability(@RequestBody Vulnerability vulnerability, @PathVariable int id) {

		vulnerability.setId(id);
		LOG.info("VulnerabilityController | updateVulnerability Begin");
		try {
			List<Map<String, Object>> vulnData = this.service.getVulnerabilityById(vulnerability.getId());
			int emp_id = BrandingDetailsController.getUser();

			boolean isGuest = brandingService.isUserGuest();
			if (isGuest) {
				return new ResponseEntity<>(ACCESS_DENIED, HttpStatus.FORBIDDEN);
			}

			vulnerability.setResearcher(String.valueOf(emp_id));
			vulnerability.setResearcherid(emp_id);
			if (vulnData == null) {
				LOG.info("VulnerabilityController | No Vulnerability found in getVulnerabilityById");
				return new ResponseEntity<>(TEXT_NO_VULN, HttpStatus.BAD_REQUEST);
			}

			String retData = this.service.validateVuln(vulnerability);
			if (retData != null) {
				LOG.info(VULN_VALIDATION);
				return new ResponseEntity<>(retData, HttpStatus.BAD_REQUEST);
			}

			if ("Approved".equals(vulnData.get(0).get(TEXT_STATUS))) {
				LOG.info("VulnerabilityController | Vulnerability is Already Approved in updateVulnerability");
				return new ResponseEntity<>("Vulnerability is Already Approved", HttpStatus.BAD_REQUEST);
			}
			if ("Rejected".equals(vulnData.get(0).get(TEXT_STATUS))) {
				LOG.info("VulnerabilityController | in updateVulnerability");
				return new ResponseEntity<>("Vulnerability is Already Rejected", HttpStatus.BAD_REQUEST);
			}

			if (!this.permissionService.isOperationPermissible(TEXT_VULNERABILITY, "Dashboard", "Edit", emp_id,
					vulnerability.getId(), 0)) {
				int researcherid = (int) vulnData.get(0).get("researcherid");
				if (researcherid == emp_id) {
					this.service.updateVulnerability(vulnerability);
					LOG.info("VulnerabilityController | updateVulnerability Exit");
					return new ResponseEntity<>("Vulnerability Upadted", HttpStatus.OK);
				}
				LOG.info("VulnerabilityController | Access Denied in updateVulnerability");
				return new ResponseEntity<String>(ACCESS_DENIED, HttpStatus.FORBIDDEN);
			}
			this.service.updateVulnerability(vulnerability);
			LOG.info("VulnerabilityController | updateVulnerability Exit");
		} catch (DataAccessException e) {
			LOG.error("VulnerabilityController | DataAccessexception in updateVulnerability - ", e);
			return new ResponseEntity<>(GLB_ERROR_MSG, HttpStatus.INTERNAL_SERVER_ERROR);
		} catch (Exception e) {
			LOG.error("VulnerabilityController | Exception in updateVulnerability", e);
			return new ResponseEntity<>(GLB_ERROR_MSG, HttpStatus.INTERNAL_SERVER_ERROR);
		}
		return new ResponseEntity<String>("Vulnerability Updated", HttpStatus.OK);

	}

	@RequestMapping(value = "vulnerabilitiesOnProject/{projectid}", method = RequestMethod.GET,produces = "application/json; charset=utf-8")
	public ResponseEntity<List<Map<String, Object>>> getVulnByProject(@PathVariable int projectid) {
		List<Map<String, Object>> retData = new ArrayList<>();
		List<Map<String, Object>> data = new ArrayList<>();
		Map<String, Object> map = new HashMap<String, Object>();
		try {
			LOG.info("VulnerabilityController | getVulnByProject Begin");
			int emp_id = BrandingDetailsController.getUser();

			boolean isGuest = brandingService.isUserGuest();
			if (isGuest) {
				map.put("text", ACCESS_DENIED);
				retData.add(map);
				return new ResponseEntity<>(retData, HttpStatus.FORBIDDEN);
			}

			data = this.service.getVulnByProject(projectid);
			retData.addAll(data);

			for (Map<String, Object> temp : retData) {
				if (!this.permissionService.isOperationPermissible(TEXT_VULNERABILITY, TEXT_VIEW_VULNERABILITY, "View",
						emp_id, (int) temp.get("id"), projectid)) {
					data.remove(temp);
				}
			}
			LOG.info("VulnerabilityController | getVulnByProject Exit");
		} catch (DataAccessException e) {
			LOG.error("VulnerabilityController | DataAccessexception in getVulnByProject - ", e);
			return new ResponseEntity<>(null, HttpStatus.INTERNAL_SERVER_ERROR);
		} catch (Exception e) {
			LOG.error("VulnerabilityController | Exception in getVulnByProject", e);
			return new ResponseEntity<>(null, HttpStatus.INTERNAL_SERVER_ERROR);
		}
		return new ResponseEntity<>(data, HttpStatus.OK);

	}

	@RequestMapping(value = "updatevulnerabilityStatus/{srno}", method = RequestMethod.POST, produces = "text/plain; charset=utf-8")
	public ResponseEntity<String> updateVulnStatus(@PathVariable int srno, @RequestBody UpdateStatus status) {

		LOG.info("VulnerabilityController | updateVulnStatus Begin");
		try {
			List<Map<String, Object>> vulnData = this.service.getVulnerabilityById(srno);
			int emp_id = BrandingDetailsController.getUser();
			status.setApprover(String.valueOf(emp_id));

			boolean isGuest = brandingService.isUserGuest();
			if (isGuest) {
				return new ResponseEntity<>(ACCESS_DENIED, HttpStatus.FORBIDDEN);
			}

			if (vulnData == null) {
				LOG.info("VulnerabilityController | No Vulnerability found in getVulnerabilityById");
				return new ResponseEntity<>(TEXT_NO_VULN, HttpStatus.BAD_REQUEST);
			}
			if ("Approved".equals(vulnData.get(0).get(TEXT_STATUS))) {
				return new ResponseEntity<>("Vulnerability is already Approved", HttpStatus.BAD_REQUEST);
			}
			if ("Rejected".equals(vulnData.get(0).get(TEXT_STATUS))) {
				return new ResponseEntity<>("Vulnerability is already Rejected", HttpStatus.BAD_REQUEST);
			}
			float cvssScore = (float) vulnData.get(0).get("cvss_score");
			int programid = (int) vulnData.get(0).get(TEXT_PROGRAMID);

			if (!this.permissionService.isOperationPermissible(TEXT_VULNERABILITY, TEXT_APPROVE, TEXT_APPROVE, emp_id, 0,
					programid)) {
				LOG.info("VulnerabilityController | Access Denied in updateVulnStatus - user lacks approval permission");
				return new ResponseEntity<>(ACCESS_DENIED, HttpStatus.FORBIDDEN);
			}

			String retData = this.service.validateVulnStatus(status, cvssScore, programid, emp_id);
			if (retData != null) {
				LOG.info(VULN_VALIDATION);
				return new ResponseEntity<>(retData, HttpStatus.BAD_REQUEST);
			}

			int approver_id = Integer.parseInt(status.getApprover());
			this.service.updateVulnStatus(srno, status.getStatus(), approver_id, status.getApproved_amount(),
					status.getRejectRemarks());
			LOG.info("VulnerabilityController | updateVulnStatus Exit");
		} catch (DataAccessException e) {
			LOG.error("VulnerabilityController | DataAccessexception in updateVulnStatus - ", e);
			return new ResponseEntity<>(GLB_ERROR_MSG, HttpStatus.INTERNAL_SERVER_ERROR);
		} catch (Exception e) {
			LOG.error("VulnerabilityController | Exception in updateVulnStatus", e);
			return new ResponseEntity<>(GLB_ERROR_MSG, HttpStatus.INTERNAL_SERVER_ERROR);
		}
		return new ResponseEntity<>("Status Updated", HttpStatus.OK);

	}

	@RequestMapping(value = "vulnerabilityCategories", method = RequestMethod.GET, produces = "application/json; charset=utf-8")
	public ResponseEntity<List<Map<String, Object>>> getVulnCategory() {
		LOG.info("VulnerabilityController | getVulnCategory Begin");
		List<Map<String, Object>> data = new ArrayList<Map<String, Object>>();
		Map<String, Object> map = new HashMap<String, Object>();
		try {

			boolean isGuest = brandingService.isUserGuest();
			if (isGuest) {
				map.put("text", ACCESS_DENIED);
				data.add(map);
				return new ResponseEntity<>(data, HttpStatus.FORBIDDEN);
			}

			data = this.service.getVulnCategory();
			LOG.info("VulnerabilityController | getVulnCategory Exit");
		} catch (DataAccessException e) {
			LOG.error("VulnerabilityController | DataAccessexception in getVulnCategory - ", e);
			return new ResponseEntity<>(null, HttpStatus.INTERNAL_SERVER_ERROR);
		} catch (Exception e) {
			LOG.error("VulnerabilityController | Exception in getVulnCategory", e);
			return new ResponseEntity<>(null, HttpStatus.INTERNAL_SERVER_ERROR);
		}
		return new ResponseEntity<>(data, HttpStatus.OK);
	}

	@RequestMapping(value = "VulnerabilityAccess/{projectid}/{vulnid}", method = RequestMethod.POST,produces = "text/plain; charset=utf-8")
	public ResponseEntity<String> provideAccess(@RequestBody TempAccess access, @PathVariable int vulnid,
			@PathVariable int projectid) {
		try {
			int login_id = BrandingDetailsController.getUser();

			boolean isGuest = brandingService.isUserGuest();
			if (isGuest) {
				return new ResponseEntity<>(ACCESS_DENIED, HttpStatus.FORBIDDEN);
			}

			if (access.getEmpid() < 0) {
				LOG.info("VulnerabilityController | Validation Failed in provideAccess");
				return new ResponseEntity<>("Employee Id Validation Failed", HttpStatus.BAD_REQUEST);
			}
			if(this.service.isEmployeePresent(access.getEmpid(),login_id, vulnid)) {
				LOG.info("VulnerabilityController | Validation Failed in providing the Access");
				return new ResponseEntity<>("Employee has already been added to the User list", HttpStatus.BAD_REQUEST);
			}
			if (String.valueOf(access.getEmpid()).length() < 4 || String.valueOf(access.getEmpid()).length() > 9) {
				LOG.info("PermissionHelperController | Validation Failed in AddBugBountyRole");
				return new ResponseEntity<>("Employee Id Validation Failed", HttpStatus.BAD_REQUEST);
			}
			
			

			String javaDate = new SimpleDateFormat("dd/MM/yyyy").format(new Date());
			String daet = new SimpleDateFormat("dd/MM/yyyy").format(access.getDate());

			if (javaDate.equals(daet)) {
				;
			} else if (access.getDate().before(new Date())) {
				LOG.info("VulnerabilityController | Validation Failed in Access Providing");
				return new ResponseEntity<>("Date Validation Failed", HttpStatus.BAD_REQUEST);
			} else {
				;
			}

			List<Map<String, Object>> vulnData = this.service.getVulnerabilityById(vulnid);
			if (vulnData == null) {
				LOG.info("VulnerabilityController | No Vulnerability found in provideAccess");
				return new ResponseEntity<>(TEXT_NO_VULN, HttpStatus.BAD_REQUEST);
			}
			Map<String, Object> tempData = this.programService.getProjectById(projectid, login_id).get(0);

			if ((int) tempData.get("bproject_ownemp_id") != login_id) {
				LOG.info("VulnerabilityController | No Vulnerability found in provideAccess");
				return new ResponseEntity<>(" No Vulnerability found in provideAccess", HttpStatus.BAD_REQUEST);
			}

			this.service.provideAccess(access.getEmpid(), access.getDate(), vulnid, login_id,access.getAccess_to());
			LOG.info("VulnerabilityController | provideAccess Exit");
		} catch (DataAccessException e) {
			LOG.error("VulnerabilityController | DataAccessexception in provideAccess - ", e);
			return new ResponseEntity<>(GLB_ERROR_MSG, HttpStatus.INTERNAL_SERVER_ERROR);
		} catch (Exception e) {
			LOG.error("VulnerabilityController | Exception in provideAccess", e);
			return new ResponseEntity<>(GLB_ERROR_MSG, HttpStatus.INTERNAL_SERVER_ERROR);
		}
		return new ResponseEntity<>("Access Updated", HttpStatus.OK);

	}
	
	@RequestMapping(value = "deleteAccess/{access_to}/{vulnid}", method = RequestMethod.GET,produces = "text/plain; charset=utf-8")
	public ResponseEntity<String> deleteAccess( @PathVariable int access_to, @PathVariable int vulnid) {
		try {
			LOG.info("VulnerabilityController | deleteAccess Begin");
			int emp_id = BrandingDetailsController.getUser();

			boolean isGuest = brandingService.isUserGuest();
			if (isGuest) {
				return new ResponseEntity<>(ACCESS_DENIED, HttpStatus.FORBIDDEN);
			}

			if (!this.permissionService.isOperationPermissible(TEXT_VULNERABILITY, TEXT_VIEW_VULNERABILITY, "View", emp_id,
					0, 0)) {
				LOG.info("VulnerabilityController | Access Denied in deleteAccess");
				return new ResponseEntity<>("ACCESS_DENIED", HttpStatus.FORBIDDEN);
			}
			
			
			
			this.service.deleteAccess(access_to, emp_id, vulnid);
			LOG.info("PermissionHelperController | deleteAccess Exit");
		} catch (DataAccessException e) {
			LOG.error("VulnerabilityAPI |Exception in deleteAccess ", e);
			return new ResponseEntity<>(GLB_ERROR_MSG, HttpStatus.INTERNAL_SERVER_ERROR);
		} catch (Exception e) {
			LOG.error("VulnerabilityAPI | Exception in deleteFAQ ", e);
			return new ResponseEntity<>(GLB_ERROR_MSG, HttpStatus.INTERNAL_SERVER_ERROR);
		}
		return new ResponseEntity<String>(TEXT_DELETE, HttpStatus.OK);
	} 

}